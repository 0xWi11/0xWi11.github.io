<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>排序算法总结 | Today is new</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://0xwi11.github.io/favicon.ico?v=1706710799621">
<link rel="stylesheet" href="https://0xwi11.github.io/styles/main.css">


  
    <link rel="stylesheet" href="https://unpkg.com/gitalk/dist/gitalk.css" />
  

  


<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="冒泡排序：
就是在前面开始，一个一个的加下标，然后两两对比将小的放在前面。
最后的效果就是把这次遍历中最大的放在了最后面。

function bubbleSort(arr) {
    var len = arr.length;
    ..." />
    <meta name="keywords" content="" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://0xwi11.github.io">
        <img src="https://0xwi11.github.io/images/avatar.png?v=1706710799621" class="site-logo">
        <h1 class="site-title">Today is new</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
        
          <a href="/post/about" class="site-nav">
            关于
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
          <a class="social-link" href="https://github.com/0xWi11?tab=overview&amp;from=2023-02-01&amp;to=2023-02-28" target="_blank">
            <i class="fab fa-github"></i>
          </a>
        
      
        
          <a class="social-link" href="https://twitter.com/0xwi11" target="_blank">
            <i class="fab fa-twitter"></i>
          </a>
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      相信美好的事情将会发生
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/getgridea/gridea" target="_blank">Gridea</a> | <a class="rss" href="https://0xwi11.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">排序算法总结</h2>
            <div class="post-date">2018-11-07</div>
            
            <div class="post-content" v-pre>
              <h2 id="冒泡排序">冒泡排序：</h2>
<p>就是在前面开始，一个一个的加下标，然后两两对比将小的放在前面。<br>
最后的效果就是把这次遍历中最大的放在了最后面。<br>
<img src="https://0xwi11.github.io/post-images/1678673748557.gif" alt="" loading="lazy"></p>
<pre><code>function bubbleSort(arr) {
    var len = arr.length;
    for (var i = 0; i &lt; len - 1; i++) {
        for (var j = 0; j &lt; len - 1 - i; j++) {
            if (arr[j] &gt; arr[j+1]) {        // 相邻元素两两对比
                var temp = arr[j+1];        // 元素交换
                arr[j+1] = arr[j];
                arr[j] = temp;
            }
        }
    }
    return arr;
}
</code></pre>
<h2 id="选择排序">选择排序：</h2>
<p>更加的直观，就是直接遍历然后把最大（小）的放在最后面（前面）。<br>
<img src="https://0xwi11.github.io/post-images/1678673792850.gif" alt="" loading="lazy"></p>
<pre><code>function selectionSort(arr) {
    var len = arr.length;
    var minIndex, temp;
    for (var i = 0; i &lt; len - 1; i++) {
        minIndex = i;
        for (var j = i + 1; j &lt; len; j++) {
            if (arr[j] &lt; arr[minIndex]) {     // 寻找最小的数
                minIndex = j;                 // 将最小数的索引保存
            }
        }
        temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    }
    return arr;
} 
</code></pre>
<h2 id="插入排序">插入排序：</h2>
<p>就是重新构建有序序列，对于未排序数据，在已排序中寻找位置插入。<br>
<img src="https://0xwi11.github.io/post-images/1678673835284.gif" alt="" loading="lazy"></p>
<pre><code>function insertionSort(arr) {
    var len = arr.length;
    var preIndex, current;
    for (var i = 1; i &lt; len; i++) {
        preIndex = i - 1;
        current = arr[i];
        while (preIndex &gt;= 0 &amp;&amp; arr[preIndex] &gt; current) {
            arr[preIndex + 1] = arr[preIndex];
            preIndex--;
        }
        arr[preIndex + 1] = current;
    }
    return arr;
}
</code></pre>
<h2 id="归并排序">归并排序</h2>
<p>好像是递归，但是在代码中看不出来。<br>
算法描述<br>
把长度为n的输入序列分成两个长度为n/2的子序列；<br>
对这两个子序列分别采用归并排序；<br>
将两个排序好的子序列合并成一个最终的排序序列。<br>
<img src="https://0xwi11.github.io/post-images/1678673880831.gif" alt="" loading="lazy"></p>
<pre><code>function mergeSort(arr) {
    var len = arr.length;
    if (len &lt; 2) {
        return arr;
    }
    var middle = Math.floor(len / 2),
        left = arr.slice(0, middle),
        right = arr.slice(middle);
    return merge(mergeSort(left), mergeSort(right));
}
 
function merge(left, right) {
    var result = [];
 
    while (left.length&gt;0 &amp;&amp; right.length&gt;0) {
        if (left[0] &lt;= right[0]) {
            result.push(left.shift());
        } else {
            result.push(right.shift());
        }
    }
 
    while (left.length)
        result.push(left.shift());
 
    while (right.length)
        result.push(right.shift());
 
    return result;
}
</code></pre>
<h2 id="快速排序">快速排序</h2>
<p>快速排序主打一个分治法，首先选择一个基点（比如<strong>第一个</strong>数据），遍历一次把比基点小的放在基点前面，遍历完之后此时基点前面都是比基点小的数了，然后进行递归到基点左边再进行一个快速排序（左边第一个），以及右边一个快速排序（右边第一个）。<br>
<img src="https://0xwi11.github.io/post-images/1678673960920.gif" alt="" loading="lazy"></p>
<pre><code>function quickSort(arr, left, right) {
    var len = arr.length,
        partitionIndex,
        left = typeof left != 'number' ? 0 : left,
        right = typeof right != 'number' ? len - 1 : right;
 
    if (left &lt; right) {
        partitionIndex = partition(arr, left, right);
        quickSort(arr, left, partitionIndex-1);
        quickSort(arr, partitionIndex+1, right);
    }
    return arr;
}
 
function partition(arr, left ,right) {     // 分区操作
    var pivot = left,                      // 设定基准值（pivot）
        index = pivot + 1;
    for (var i = index; i &lt;= right; i++) {
        if (arr[i] &lt; arr[pivot]) {
            swap(arr, i, index);
            index++;
        }       
    }
    swap(arr, pivot, index - 1);
    return index-1;
}
 
function swap(arr, i, j) {
    var temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}
</code></pre>
<h2 id="计数排序">计数排序</h2>
<p>使用限制非常的大。1、数值不能够过多。2、需要是整类型的数值<br>
核心在于将输入的数据值转化为键存储在额外开辟的数组空间中<br>
<img src="https://0xwi11.github.io/post-images/1678673988498.gif" alt="" loading="lazy"></p>
<pre><code>function countingSort(arr, maxValue) {
    var bucket = new Array(maxValue + 1),
        sortedIndex = 0;
        arrLen = arr.length,
        bucketLen = maxValue + 1;
 
    for (var i = 0; i &lt; arrLen; i++) {
        if (!bucket[arr[i]]) {
            bucket[arr[i]] = 0;
        }
        bucket[arr[i]]++;
    }
 
    for (var j = 0; j &lt; bucketLen; j++) {
        while(bucket[j] &gt; 0) {
            arr[sortedIndex++] = j;
            bucket[j]--;
        }
    }
 
    return arr;
}
</code></pre>
<h2 id="桶排序">桶排序</h2>
<p>桶排序就是升级版的计数排序，就是将表和对比大小的逻辑升级，放入桶中的时候，桶本身还会调用函数去对已经入桶的数据进行排序。<br>
<img src="https://0xwi11.github.io/post-images/1678674019365.png" alt="" loading="lazy"></p>
<pre><code>function bucketSort(arr, bucketSize) {
    if (arr.length === 0) {
      return arr;
    }
 
    var i;
    var minValue = arr[0];
    var maxValue = arr[0];
    for (i = 1; i &lt; arr.length; i++) {
      if (arr[i] &lt; minValue) {
          minValue = arr[i];                // 输入数据的最小值
      } else if (arr[i] &gt; maxValue) {
          maxValue = arr[i];                // 输入数据的最大值
      }
    }
 
    // 桶的初始化
    var DEFAULT_BUCKET_SIZE = 5;            // 设置桶的默认数量为5
    bucketSize = bucketSize || DEFAULT_BUCKET_SIZE;
    var bucketCount = Math.floor((maxValue - minValue) / bucketSize) + 1;  
    var buckets = new Array(bucketCount);
    for (i = 0; i &lt; buckets.length; i++) {
        buckets[i] = [];
    }
 
    // 利用映射函数将数据分配到各个桶中
    for (i = 0; i &lt; arr.length; i++) {
        buckets[Math.floor((arr[i] - minValue) / bucketSize)].push(arr[i]);
    }
 
    arr.length = 0;
    for (i = 0; i &lt; buckets.length; i++) {
        insertionSort(buckets[i]);                      // 对每个桶进行排序，这里使用了插入排序
        for (var j = 0; j &lt; buckets[i].length; j++) {
            arr.push(buckets[i][j]);                     
        }
    }
 
    return arr;
}
</code></pre>
<h2 id="基数排序">基数排序</h2>
<p>先排个位数，然后再排十位、百位，每次排序之后的顺序不是乱的，所以说最后之前排的序数还保留着，一直到最后都是有顺序的。<br>
<img src="https://0xwi11.github.io/post-images/1678674044640.gif" alt="" loading="lazy"></p>
<pre><code>var counter = [];
function radixSort(arr, maxDigit) {
    var mod = 10;
    var dev = 1;
    for (var i = 0; i &lt; maxDigit; i++, dev *= 10, mod *= 10) {
        for(var j = 0; j &lt; arr.length; j++) {
            var bucket = parseInt((arr[j] % mod) / dev);
            if(counter[bucket]==null) {
                counter[bucket] = [];
            }
            counter[bucket].push(arr[j]);
        }
        var pos = 0;
        for(var j = 0; j &lt; counter.length; j++) {
            var value = null;
            if(counter[j]!=null) {
                while ((value = counter[j].shift()) != null) {
                      arr[pos++] = value;
                }
          }
        }
    }
    return arr;
}
</code></pre>

            </div>
            
            

            
              
                <div id="gitalk-container" data-aos="fade-in"></div>
              

              
            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>





  
    <script src="https://unpkg.com/gitalk/dist/gitalk.min.js"></script>
    <script>

      var gitalk = new Gitalk({
        clientID: 'b2be97bd4f11fa2c7ed0',
        clientSecret: '7cd82370c455720ef14b1c828ee50582651f71c4',
        repo: 'bolg-comment',
        owner: '0xWi11',
        admin: ['0xWi11'],
        id: (location.pathname).substring(0, 49),      // Ensure uniqueness and length less than 50
        distractionFreeMode: false  // Facebook-like distraction free mode
      })

      gitalk.render('gitalk-container')

    </script>
  

  




  </body>
</html>
